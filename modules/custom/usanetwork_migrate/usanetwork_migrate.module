<?php

/**
 * Helper that takes a node entity and array of SimpleXMLElement objects and
 * attaches taxonomy terms to the node preserving hierarchy.
 */
function _usanetwork_migrate_attach_video_categories(&$entity, $category_elements) {

  // Ensure an array if given a single SimpleXMLElement object.
  if (!is_array($category_elements)) {
    if (is_object($category_elements) && $category_elements instanceof SimpleXMLElement) {
      $category_elements = array($category_elements);
    }
    // Bail if passed an unexpected object.
    else {
      return FALSE;
    }
  }

  foreach ($category_elements as $element) {
    if ($element instanceof SimpleXMLElement) {
      $element_value = (string)$element;
      // Fetch term ID from the array of term names.
      $element_term_hierarchy = explode('/', $element_value);
      _usanetwork_migrate_add_video_term_by_hierarchy($entity, $element_term_hierarchy);
    }
  }
}

/**
 * Helper that returns the vid for the 'usa_video_terms' vocabulary.
 */
function _usanetwork_migrate_get_usa_video_terms_vid() {

  static $vid;

  if (empty($vid)) {
    $vid = db_query("SELECT vid FROM {taxonomy_vocabulary} WHERE machine_name = :machine_name",
        array(':machine_name' => 'usa_video_terms'))->fetchField();
  }

  return $vid;
}

/**
 * Helper that returns an array of terms that can be attached to a node entity
 * given an array of term names in a hierarchical structure.
 */
function _usanetwork_migrate_add_video_term_by_hierarchy(&$entity, $term_hierarchy) {

  // Return empty array if $term_hierachy is empty.
  if (empty($term_hierarchy)) {
    return array();
  }

  // Get the vocabulary id for 'usa_video_terms'.
  $vocabulary_id = _usanetwork_migrate_get_usa_video_terms_vid();

  // Start with the top level of the taxonomy tree.
  $parent_tid = 0;
  $parent_children = taxonomy_get_tree($vocabulary_id, $parent_tid, 1);

  foreach ($term_hierarchy as $term_name) {
    // Check if the term exists by looking through its parent's child terms.
    $tid = NULL;
    foreach ($parent_children as $child_term) {
      if ($term_name == $child_term->name) {
        $tid = $child_term->tid;
      }
    }
    // Create the term if it does not exist.
    if (is_null($tid)) {
      $tid = _usanetwork_migrate_create_term($term_name, $parent_tid);
      // Abort if we could not save the new term.
      if ($tid === FALSE) {
        return FALSE;
      }
    }
    // Reset the parent tid and children array for the next level down.
    $parent_tid = $tid;
    $parent_children = taxonomy_get_tree($vocabulary_id, $parent_tid, 1);
  }

  // Now add the final term in the hierarchy to the node.
  if ($parent_tid) {
    $entity->field_usa_video_terms[ LANGUAGE_NONE ][]['target_id'] = $parent_tid;
  }
}


/**
 * Helper that creates a new term by name.
 */
function _usanetwork_migrate_create_term($term_name, $parent_tid = 0) {

  $new_term = new stdClass();
  $new_term->vid = _usanetwork_migrate_get_usa_video_terms_vid();
  $new_term->name = $term_name;
  $new_term->parent = $parent_tid;

  $result = taxonomy_term_save($new_term);

  if ($result !== SAVED_NEW) {
    watchdog('usanetwork_migrate',
        'Failed to create term "@term_name" with parent tid "@parent_tid".',
        array('@term_name' => $term_name, '@parent_tid' => $parent_tid));
  }

  return isset($new_term->tid) ? $new_term->tid : FALSE;
}

/**
 * Helper that takes an array of video category SimpleXMLElement objects and
 * attaches the entity reference to the appropriate TV Show.
 */
function _usanetwork_migrate_attach_video_tv_show_reference(&$entity, $term_hierarchy) {

  // Return empty array if $term_hierachy is empty.
  if (empty($term_hierarchy)) {
    return FALSE;
  }

  // TV Show names are pulled from a category with the form "Series/[Name]/...".
  $tv_show_nids = array();

  foreach ($term_hierarchy as $category) {
    $show_name = trim(preg_replace('|^Series/([^/]*)/?.*$|', '$1', $category));
    if ($show_name) {
      $show_query = new EntityFieldQuery();
      $show_query->entityCondition('entity_type', 'node');
      $show_query->entityCondition('bundle', 'tv_show');
      $show_query->propertyCondition('title', $show_name);
      $show_result = $show_query->execute();
      if (!empty($show_result['node'])) {
        foreach ($show_result['node'] as $result) {
          $tv_show_nids[ $result->nid ] = $result->nid;
        }
      }
    }
  }

  foreach ($tv_show_nids as $nid) {
    $entity->field_show[ LANGUAGE_NONE ][]['target_id'] = $nid;
  }
}


/**
 * Implements hook_cron().
 */
function usanetwork_migrate_cron() {

  // Process nodes scheduled to be unpublished in field_publish_date.
  $results = usanetwork_migrate_get_scheduled_nodes();
  $queue = DrupalQueue::get('usanetwork_migrate');

  foreach ($results as $result) {
    $queue->createItem($result);
  }

  // Run migration to update content.
  global $usanetwork_migrate_is_cron;

  $usanetwork_migrate_is_cron = TRUE;
  $machine_names = array('usanetwork_tve_videos', 'usanetwork_mpx_videos');

  foreach ($machine_names as $machine_name) {
    $migration = Migration::getInstance($machine_name);
    // Prepare to Update the contents/data
    $migration->prepareUpdate();
    // Trigger the migration
    $result = $migration->processImport();
  }
}

/*
 * Implements hook_cron_queue_info().
 */
function usanetwork_migrate_cron_queue_info() {

  $queues['usanetwork_migrate'] = array(
    'worker callback' => 'usanetwork_migrate_process_item',
    'time' => 60,
  );

  return $queues;
}

/**
 * Process scheduled nodes to fire unpublish state flow event.
 *
 * @param object $data
 */
function usanetwork_migrate_process_item($data) {

  global $user;

  $user = user_load(1);
  $node = node_load($data->nid, $data->vid);

  drupal_set_message('Attempting to unpublish nid:' . $node->nid . ', vid:' . $node->vid);

  $state_flow = state_flow_load_state_machine($node, TRUE);
  $state_flow->fire_event('unpublish', $user->uid, 'Unpublished on cron.');
}

/**
 * Return all nodes scheduled to be published
 *
 * @param int $nid
 * @param int $vid
 * @param int $date
 * @return object
 */
function usanetwork_migrate_get_scheduled_nodes() {

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node');
  $query->fieldCondition('field_publish_date', 'value2', REQUEST_TIME, '<=');
  $query_result = $query->execute();

  return isset($query_result['node']) ? $query_result['node'] : array();
}












