<?php


define('USANETWORK_MIGRATE_UNPUBLISH_QUEUE', 'usanetwork_migrate_unpublish_content');
define('USANETWORK_MIGRATE_STATE_FLOW_FIX_QUEUE', 'usanetwork_migrate_state_flow_fix');


/**
 * Helper that takes a node entity and array of SimpleXMLElement objects and
 * attaches taxonomy terms to the node preserving hierarchy.
 */
function _usanetwork_migrate_attach_video_categories(&$entity, $category_elements) {

  // Ensure an array if given a single SimpleXMLElement object.
  if (!is_array($category_elements)) {
    if (is_object($category_elements) && $category_elements instanceof SimpleXMLElement) {
      $category_elements = array($category_elements);
    }
    // Bail if passed an unexpected object.
    else {
      return FALSE;
    }
  }

  foreach ($category_elements as $element) {
    if ($element instanceof SimpleXMLElement) {
      $element_value = (string)$element;
      // Fetch term ID from the array of term names.
      $element_term_hierarchy = explode('/', $element_value);
      _usanetwork_migrate_add_video_term_by_hierarchy($entity, $element_term_hierarchy);
    }
  }
}

/**
 * Helper that returns the vid for the 'usa_video_terms' vocabulary.
 */
function _usanetwork_migrate_get_usa_video_terms_vid() {

  static $vid;

  if (empty($vid)) {
    $vid = db_query("SELECT vid FROM {taxonomy_vocabulary} WHERE machine_name = :machine_name",
        array(':machine_name' => 'usa_video_terms'))->fetchField();
  }

  return $vid;
}

/**
 * Helper that returns an array of terms that can be attached to a node entity
 * given an array of term names in a hierarchical structure.
 */
function _usanetwork_migrate_add_video_term_by_hierarchy(&$entity, $term_hierarchy) {

  // Return empty array if $term_hierachy is empty.
  if (empty($term_hierarchy)) {
    return array();
  }

  // Get the vocabulary id for 'usa_video_terms'.
  $vocabulary_id = _usanetwork_migrate_get_usa_video_terms_vid();

  // Start with the top level of the taxonomy tree.
  $parent_tid = 0;
  $parent_children = taxonomy_get_tree($vocabulary_id, $parent_tid, 1);

  foreach ($term_hierarchy as $term_name) {
    // Check if the term exists by looking through its parent's child terms.
    $tid = NULL;
    foreach ($parent_children as $child_term) {
      if ($term_name == $child_term->name) {
        $tid = $child_term->tid;
      }
    }
    // Create the term if it does not exist.
    if (is_null($tid)) {
      $tid = _usanetwork_migrate_create_term($term_name, $parent_tid);
      // Abort if we could not save the new term.
      if ($tid === FALSE) {
        return FALSE;
      }
    }
    // Reset the parent tid and children array for the next level down.
    $parent_tid = $tid;
    $parent_children = taxonomy_get_tree($vocabulary_id, $parent_tid, 1);
  }

  // Now add the final term in the hierarchy to the node.
  if ($parent_tid) {
    $entity->field_usa_video_terms[ LANGUAGE_NONE ][]['target_id'] = $parent_tid;
  }
}


/**
 * Helper that creates a new term by name.
 */
function _usanetwork_migrate_create_term($term_name, $parent_tid = 0) {

  $new_term = new stdClass();
  $new_term->vid = _usanetwork_migrate_get_usa_video_terms_vid();
  $new_term->name = $term_name;
  $new_term->parent = $parent_tid;

  $result = taxonomy_term_save($new_term);

  if ($result !== SAVED_NEW) {
    watchdog('usanetwork_migrate',
        'Failed to create term "@term_name" with parent tid "@parent_tid".',
        array('@term_name' => $term_name, '@parent_tid' => $parent_tid));
    drupal_set_message(t('Failed to create term "@term_name" with parent tid "@parent_tid".',
        array('@term_name' => $term_name, '@parent_tid' => $parent_tid)));
  }

  return isset($new_term->tid) ? $new_term->tid : FALSE;
}

/**
 * Helper that takes an array of video category SimpleXMLElement objects and
 * attaches the entity reference to the appropriate TV Show.
 */
function _usanetwork_migrate_attach_video_tv_show_reference(&$entity, $term_hierarchy) {

  // Return empty array if $term_hierachy is empty.
  if (empty($term_hierarchy)) {
    return FALSE;
  }

  // TV Show names are pulled from a category with the form "Series/[Name]/...".
  $tv_show_nids = array();

  foreach ($term_hierarchy as $category) {
    $show_name = trim(preg_replace('|^Series/([^/]*)/?.*$|', '$1', $category));
    if ($show_name) {
      $show_query = new EntityFieldQuery();
      $show_query->entityCondition('entity_type', 'node');
      $show_query->entityCondition('bundle', 'tv_show');
      $show_query->propertyCondition('title', $show_name);
      $show_result = $show_query->execute();
      if (!empty($show_result['node'])) {
        foreach ($show_result['node'] as $result) {
          $tv_show_nids[ $result->nid ] = $result->nid;
        }
      }
    }
  }

  foreach ($tv_show_nids as $nid) {
    $entity->field_show[ LANGUAGE_NONE ][]['target_id'] = $nid;
  }
}


/**
 * Implements hook_cron().
 */
function usanetwork_migrate_cron() {

  if (!variable_get('usanetwork_migrate_run_cron', TRUE)) {
    return;
  }

  // Process nodes scheduled to be unpublished in field_publish_date, but only
  // if the current queue is empty.  Since data is stored in binary format,
  $queue_name = USANETWORK_MIGRATE_UNPUBLISH_QUEUE;

  $queue = DrupalQueue::get($queue_name);
  $queued_node_nids = _usanetwork_migrate_get_queued_items($queue_name, 'nid');
  $results = usanetwork_migrate_get_nodes_to_unpublish();
  $queued_items = array();

  foreach ($results as $result) {
    if (!in_array($result->nid, $queued_node_nids)) {
      $queue->createItem($result);
      $queued_items[] = $result;
    }
  }

  watchdog('usanetwork_migrate', 'Populated the custom Unpublish Queue with the following items: @items',
      array('@items' => print_r($queued_items, TRUE)));
  drupal_set_message(t('USANETWORK MIGRATE:  Populated the custom Unpublish Queue with the following items: @items',
      array('@items' => print_r($queued_items, TRUE))));

  // Process state_flow_schedule queue items so that they can be transferred to
  // the published state.
  $queue_name = USANETWORK_MIGRATE_STATE_FLOW_FIX_QUEUE;

  $queue = DrupalQueue::get($queue_name);
  $queued_node_nids = _usanetwork_migrate_get_queued_items($queue_name, 'nid');
  $scheduled_nodes = db_query("SELECT * FROM {state_flow_schedule} ORDER BY sid ASC")->fetchAllAssoc('nid');
  $queued_items = array();

  foreach ($scheduled_nodes as $nid => $row) {
    if (!in_array($row->nid, $queued_node_nids)) {
      $queue->createItem($row);
      $queued_items[] = $result;
    }
  }

  watchdog('usanetwork_migrate', 'Populated the custom State Flow Fix Queue with the following items: @items',
      array('@items' => print_r($queued_items, TRUE)));
  drupal_set_message(t('USANETWORK MIGRATE:  Populated the custom State Flow Fix Queue with the following items: @items',
      array('@items' => print_r($queued_items, TRUE))));


  // Run migration to update content.
  //*  Comment this block out when the migration update crontab goes live.
  global $usanetwork_migrate_is_cron;

  $usanetwork_migrate_is_cron = TRUE;
  $machine_names = array('usanetwork_tve_videos', 'usanetwork_mpx_videos');
  #$machine_names = array('usanetwork_mpx_videos');

  foreach ($machine_names as $machine_name) {
    // Log that we're starting this update.
    watchdog('usanetwork_migrate', 'Starting @migration migration update.',
        array('@migration' => $machine_name), WATCHDOG_NOTICE);
    drupal_set_message(t('USANETWORK MIGRATE:  Starting @migration migration update.',
        array('@migration' => $machine_name)));
    $migration = Migration::getInstance($machine_name);
    // Prepare to Update the contents/data
    $migration->prepareUpdate();
    // Trigger the migration
    $result = $migration->processImport();
    // Log that we've completed this update.
    watchdog('usanetwork_migrate', 'Completed @migration migration update.',
        array('@migration' => $machine_name), WATCHDOG_NOTICE);
    drupal_set_message(t('USANETWORK MIGRATE:  Completed @migration migration update.',
        array('@migration' => $machine_name)));
  }
  //*/  <-- Up to here.  (Migration Update)

  // Clearing the cache fixes some access issues for newly published nodes.
  _usanetwork_migrate_cron_cache_clear();
}

/*
 * Implements hook_cron_queue_info().
 */
function usanetwork_migrate_cron_queue_info() {

  $queues[USANETWORK_MIGRATE_UNPUBLISH_QUEUE] = array(
    'worker callback' => 'process_usanetwork_migrate_unpublish_content_item',
    'time' => 3,
  );
  $queues[USANETWORK_MIGRATE_STATE_FLOW_FIX_QUEUE] = array(
    'worker callback' => 'process_usanetwork_migrate_state_flow_fix_item',
    'time' => 3,
  );

  return $queues;
}

/**
 * Process state flow schedule queue items to prepare them for publishing.
 *
 * @param object $data
 */
function process_usanetwork_migrate_state_flow_fix_item($data) {

  $node = node_load($data->nid);

  if (!is_object($node) || !isset($node->nid)) {
    return;
  }

  $entity_state_machine =& state_flow_load_state_machine($node);
  $current_entity_state = $entity_state_machine->get_current_state();

  // If the node is published...
  if ($current_entity_state == 'published') {

    // If a node's status property is 0 (zero), then set it to 1 and save.
    if ($node->status == 0) {
      $node->status = 1;
      node_save($node);
      watchdog('usanetwork_migrate', 'Set status to 1 for node @nid that was already in a published State Flow state.',
          array('@nid' => $node->nid));
      drupal_set_message(t('USANETWORK MIGRATE:  Set status to 1 for node @nid that was already in a published State Flow state.',
          array('@nid' => $node->nid)));
    }

    // Ensure the node is no longer in the state_flow_schedule queueu.  It will
    // get stuck there as the state_flow_schedule module fails when it tries to
    // publish a scheduled node that is already published.
    $result = db_delete('state_flow_schedule')
        ->condition('nid', $entity->nid)
        ->execute();
    if ($result) {
      watchdog('usanetwork_migrate', 'Removed record for node @nid from state_flow_schedule table.',
          array('@nid' => $node->nid));
      drupal_set_message(t('Removed record for node @nid from state_flow_schedule table.',
          array('@nid' => $node->nid)));
    }
  }
  else if ($current_entity_state != 'scheduled') {

    _usanetwork_migrate_complete_entity_state_transition($node, 'draft');

    watchdog('usanetwork_migrate', 'Transitioned node @nid to a draft State Flow state.',
        array('@nid' => $node->nid));
    drupal_set_message(t('USANETWORK MIGRATE:  Transitioned node @nid to a draft State Flow state.',
        array('@nid' => $node->nid)));
  }
}

/**
 * Process scheduled nodes to fire unpublish state flow event.
 *
 * @param object $data
 */
function process_usanetwork_migrate_unpublish_content_item($data) {

  $node = node_load($data->nid, $data->vid);

  watchdog('usanetwork_migrate', 'USANetwork Migrate:  Attempting to unpublish nid: @nid, vid: @vid.',
      array('@nid' => $data->nid, '@vid' => $data->vid));
  drupal_set_message('USANetwork Migrate:  Attempting to unpublish nid:' . $node->nid . ', vid:' . $node->vid);

  _usanetwork_migrate_complete_entity_state_transition($node, 'unpublished');

  // Reload the node and ensure it is saved with a status of 0.
  $node = node_load($node->nid, NULL, TRUE);
  $node->status = 0;
  node_save($node);
}

/**
 * Helper that returns the items in a queue.
 */
function _usanetwork_migrate_get_queued_items($queue_name, $data_field, $limit = NULL) {

  // Keeping disabled for now.
  if ($limit && FALSE) {
    $query = "SELECT * FROM queue WHERE name = :queue_name ORDER BY item_id DESC LIMIT " . (int)$limit;
    $query_args = array(':queue_name' => $queue_name);
  }
  else {
    $query = "SELECT * FROM queue WHERE name = :queue_name ORDER BY item_id DESC";
    $query_args = array(':queue_name' => $queue_name);
  }

  $query_result = db_query($query, $query_args);

  // Get the data field for each queued item.
  $queued_items = array();
  foreach ($query_result as $result) {
    $data = unserialize($result->data);
    if (is_object($data) && isset($data->{$data_field})) {
      $queued_items[ $data->{$data_field} ] = $data->{$data_field};
    }
  }

  return $queued_items;
}

/**
 * Return all nodes scheduled to be published
 */
function usanetwork_migrate_get_nodes_to_unpublish() {

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node');
  $query->propertyCondition('status', 1);
  $query->fieldCondition('field_publish_date', 'value2', 0, '>');
  $query->fieldCondition('field_publish_date', 'value2', REQUEST_TIME, '<=');
  $query_result = $query->execute();

  return isset($query_result['node']) ? $query_result['node'] : array();
}

/**
 * Helper function that properly transitions an entity to the desired state flow state.
 */
function _usanetwork_migrate_complete_entity_state_transition(&$entity, $end_state) {

  module_load_include('inc', 'state_flow', 'state_flow.pages');

  $entity_state_machine =& state_flow_load_state_machine($entity);
  $current_entity_state = $entity_state_machine->get_current_state();
  $transition_states = array();

  watchdog('usanetwork_migrate', 'Transition node @nid from @current_state to @end_state',
      array('@nid' => $entity->nid, '@current_state' => $current_entity_state, '@end_state' => $end_state));
  drupal_set_message(t('USANETWORK MIGRATE:  Transition node @nid from @current_state to @end_state',
      array('@nid' => $entity->nid, '@current_state' => $current_entity_state, '@end_state' => $end_state)));

  switch ($current_entity_state) {

    case 'unpublished':
      switch ($end_state) {
        case 'unpublished':
          // Don't do anything.
          break;
        case 'draft':
          $transition_states = array('to draft');
          break;
        case 'published':
          $transition_states = array('to draft', 'publish');
      }
      break;

    case 'draft':
      switch ($end_state) {
        case 'unpublished':
          // TODO: Go to scheduled state, then to unpublished, or goto published
          // state, then to unpublished?  May not be needed.
          break;
        case 'draft':
          // Don't do anything.
          break;
        case 'published':
          $transition_states = array('publish');
      }
      break;

    case 'published':
      switch ($end_state) {
        case 'unpublished':
          $transition_states = array('unpublish');
          break;
        case 'draft':
          $transition_states = array('unpublish', 'to draft');
          break;
        case 'published':
          // Don't do anything.
      }
      break;
  }

  // Now perform the necessary entity state transitions individually.
  foreach ($transition_states as $state) {
    _usanetwork_migrate_transition_entity_state($entity, $state, $entity_state_machine);
  }
}


/**
 * Helper that performs a single entity state transition.
 */
function _usanetwork_migrate_transition_entity_state($entity, $transition, $entity_state_machine) {

  $state_flow_form = array();
  $state_flow_form_state = array();

  $state_flow_form_state['values'] = array(
    'node_revision' => $entity,
    'state_flow' => $entity_state_machine,
    'event' => $transition,
    'event_comment' => t('Transitioning to "@transition" via migration script.',
          array('@transition' => ucwords($transition))),
  );

  state_flow_events_revision_submit($state_flow_form, $state_flow_form_state);
}

/**
 * Helper to clear caches on cron.
 */
function _usanetwork_migrate_cron_cache_clear() {

  $core = array(
    'cache',
    'cache_path',
    'cache_filter',
    'cache_bootstrap',
    'cache_page',
  );
  $cache_tables = array_merge(module_invoke_all('flush_caches'), $core);
  foreach ($cache_tables as $table) {
    cache_clear_all('*', $table, TRUE);
  }

  watchdog('usanetwork_migrate', 'Ran custom cache clear on cron.');
  drupal_set_message(t('Ran custom cache clear on cron.'));
}
